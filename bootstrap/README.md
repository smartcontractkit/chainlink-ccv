# Bootstrap package

The `bootstrap` package aims to serve as a starting point for launching all CCIP standalone applications. It takes care of the following:

* Making sure that the keystore is available and healthy.
* Receiving updates from the job-distributor (JD) and handling lifecycle changes.

# Configuration

The `bootstrap` functionality is configured by having a TOML file with the following structure:

```toml
[jd]
# Holds JD-specific configuration, namely the server WSRPC endpoint and the server CSA key.
server_wsrpc_url = "ws://localhost:8080/ws"
server_csa_public_key = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

[keystore]
# Keystore password, this should be fairly high entropy.
password = "password"

[db]
# DB URL for the bootstrap DB (separate from app DB, but can be on the same server).
url = "postgres://localhost:5432/bootstrapper"
```

# Requirements

The `bootstrap` functionality requires a database to ensure full functionality of all CCIP apps. The database will store the following:

* Job specs sent by JD
* Keys generated by the keystore (encrypted by a password)

This database should be a separate postgres database but can be running on the same server. This is because we don't want migrations for
the bootstrapper to affect other apps.

# Usage Example

Below is some expected usage of the `bootstrap` library. 

```golang
type config struct {
    MyField1 string `toml:"myfield1"`
    MyField2 string `toml:"myfield2"`
}

// serviceFactory implements bootstrap.ServiceFactory
type serviceFactory struct {
    // ... fields ...
}

func (v *serviceFactory) Start(ctx context.Context, cfg config, deps bootstrap.ServiceDeps) error {
    // TODO: implement
}

func (v *serviceFactory) Stop(ctx context.Context) error {
    // TODO: implement
}

func main() {
    err := bootstrap.Run(
        "CommitteeVerifier",
        &serviceFactory{}, 
        // debug logging, default is zapcore.InfoLevel
        bootstrap.WithLogLevel[config](zapcore.DebugLevel),
    )
    if err != nil {
        panic(fmt.Sprintf("failed to run: %w", err))
    }
}
```
