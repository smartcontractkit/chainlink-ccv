{{- $global := . -}}
{{- range until (include "chainlink-cluster.clusterSize" . | int) }}
  {{- $merged := dict "common" $global.Values.common "overrides" $global.Values.overrides "idx" . | include "chainlink-cluster.merged" | fromYaml -}}
  {{- if and ($global.Values.enabled) ($global.Values.rollout.enabled) }}
  {{- $nodeName :=  dict "global" $global "merged" $merged "idx" . | include "chainlink-cluster.nodeName" -}}
  {{- $labels := dict "global" $global "merged" $merged "nodeName" $nodeName | include "chainlink-cluster.labelMachine" | fromYaml }}
---
kind: AnalysisTemplate
apiVersion: argoproj.io/v1alpha1
metadata:
  name: {{ $nodeName }}-hc
  labels: {{ $labels.instance | nindent 4 }}
spec:
  metrics:
    # How this works:
    # - If UI port is not accessible, the return code is Error, not Failure or Success.
    # - When return code is Error, AnalysisRun does not count it as 1 run, and continue to retry until reach consecutiveErrorLimit
    # - This works in our case, if UI port is not ready, it's always timeout and return code is Error
    # - The run becomes immediately success when UI port is ready, thus `count=1` is enough
    # - Max time allowance = (consecutiveErrorLimit x interval) + analysisInitialDelay = 100s + analysisInitialDelay
    # - successCondition checks the response body, in our case as long as there's response body, it's successful. Thus always "true".
  - name: hc-http
    count: 1
    consecutiveErrorLimit: {{ $global.Values.rollout.analysisConsecutiveErrorLimit }}
    successCondition: "true"
    initialDelay: {{ $global.Values.rollout.analysisInitialDelay }}
    interval: {{ $global.Values.rollout.analysisInterval }}
    provider:
      web:
        url: http://{{ $nodeName }}-preview.{{ $global.Release.Namespace }}:6688
        timeoutSeconds: 2
  {{- end }}
{{- end }}
