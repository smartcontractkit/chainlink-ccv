package config

import (
	"errors"
	"fmt"
	"os"

	"github.com/BurntSushi/toml"

	hmacutil "github.com/smartcontractkit/chainlink-ccv/protocol/common/hmac"
)

// GeneratedVerifierConfig contains auto-generated verifier configuration.
type GeneratedVerifierConfig struct {
	Name            string   `toml:"Name"`
	IssuerAddresses []string `toml:"IssuerAddresses"`
}

// GeneratedConfig contains auto-generated deployment configuration.
// This is typically generated by tooling and loaded from a separate file.
type GeneratedConfig struct {
	Verifier []GeneratedVerifierConfig `toml:"Verifier"`
}

// Config provides all configuration for the indexer.
type Config struct {
	// GeneratedConfigPath is the path to the auto-generated configuration file.
	// If relative, it is resolved relative to the main config file location.
	GeneratedConfigPath string `toml:"GeneratedConfigPath"`
	LogLevel            string `toml:"LogLevel"`
	// Monitoring is the configuration for the monitoring system inside the indexer.
	Monitoring MonitoringConfig `toml:"Monitoring"`
	// Discoveries is the list of discovery configs (aggregators) for message discovery.
	Discoveries []DiscoveryConfig `toml:"Discoveries"`
	// Scheduler is the configuration for the scheduling component inside the indexer.
	Scheduler SchedulerConfig `toml:"Scheduler"`
	// Pool is the configuration for the worker pool within the indexer.
	Pool PoolConfig `toml:"Pool"`
	// Verifiers contains the configured verifiers known to the indexer.
	Verifiers []VerifierConfig `toml:"Verifier"`
	// Storage is the configuration for the storage inside the indexer.
	Storage StorageConfig `toml:"Storage"`
	// API is the configuration for the API inside the indexer.
	API APIConfig `toml:"API"`
}

type SchedulerConfig struct {
	// TickerInterval defines the number of milliseconds to wait before running the next scheduling loop.
	TickerInterval int `toml:"TickerInterval"`
	// VerificationVisibilityWindow defines the number of seconds before we will no longer attempt to retrieve verifications.
	VerificationVisibilityWindow int `toml:"VerificationVisibilityWindow"`
	// BaseDelay defines the minimum number of milliseconds to wait before retrying the message.
	BaseDelay int `toml:"BaseDelay"`
	// MaxDelay defines the maximum number of milliseconds to wait before retrying the message.
	MaxDelay int `toml:"MaxDelay"`
}

type PoolConfig struct {
	// ConcurrentWorkers is the maximum number of concurrent workers, equates to maximum number of concurrent messages being indexed.
	ConcurrentWorkers int `toml:"ConcurrentWorkers"`
	// WorkerTimeout is the number of seconds a worker can attempt to retrieve verifications for
	// Note: This value should always be higher then the maximum timeout on the slowest configured verifier.
	WorkerTimeout int `toml:"WorkerTimeout"`
}

// APIConfig provides all configuration for the API inside the indexer.
type APIConfig struct {
	// ListenPort is the port the HTTP API listens on inside the process (default 8100).
	// Used by devenv to expose the correct container port and build internal URLs.
	ListenPort int `toml:"ListenPort"`
	// RateLimit is the configuration for the rate limiting system inside the indexer.
	RateLimit RateLimitConfig `toml:"RateLimit"`
	// TrustedProxies contains an array of trusted reverse proxies.
	TrustedProxies []string `toml:"TrustedProxies"`
}

// RateLimitConfig provides all configuration for the rate limiting system inside the indexer.
type RateLimitConfig struct {
	// Enabled enables the rate limiting system inside the indexer.
	Enabled bool `toml:"Enabled"`
}

// StorageConfig allows you to change the storage strategy used by the indexer.
type StorageConfig struct {
	Strategy StorageStrategy      `toml:"Strategy"`
	Single   *SingleStorageConfig `toml:"Single"`
}

// StorageStrategy defines the storage strategy to use.
type StorageStrategy string

const (
	StorageStrategySingle StorageStrategy = "single"
)

// SingleStorageConfig provides configuration for a single storage backend.
type SingleStorageConfig struct {
	Type     StorageBackendType `toml:"Type"`
	Postgres *PostgresConfig    `toml:"Postgres"`
}

// PostgresConfig provides configuration for the postgres storage backend.
type PostgresConfig struct {
	// URI is the connection string for the postgres database.
	URI string `toml:"URI"`
	// MaxOpenConnections is the maximum number of open connections to the database.
	MaxOpenConnections int `toml:"MaxOpenConnections"`
	// MaxIdleConnections is the maximum number of idle connections to the database.
	MaxIdleConnections int `toml:"MaxIdleConnections"`
	// IdleInTxSessionTimeout is the idle_in_transaction_session_timeout in seconds.
	IdleInTxSessionTimeout int64 `toml:"IdleInTxSessionTimeout"`
	// LockTimeout is the lock_timeout in seconds.
	LockTimeout int64 `toml:"LockTimeout"`
}

// StorageBackendType is the type of storage backend to use (memory, postgres).
type StorageBackendType string

const (
	StorageBackendTypePostgres StorageBackendType = "postgres"
)

// DiscoveryConfig allows you to change the discovery system used by the indexer.
type DiscoveryConfig struct {
	AggregatorReaderConfig
	PollInterval int    `toml:"PollInterval"`
	Timeout      int    `toml:"Timeout"`
	NtpServer    string `toml:"NtpServer"`
	// MaxResponseBytes is the maximum response size in bytes the client will accept.
	// 0 uses DefaultMaxResponseBytes (4MB).
	MaxResponseBytes int `toml:"MaxResponseBytes"`
}

type VerifierConfig struct {
	Type            ReaderType `toml:"Type"`
	IssuerAddresses []string   `toml:"IssuerAddresses"`
	Name            string     `toml:"Name"`
	// BatchSize is the maximum batch size to send to the verifier.
	BatchSize int `toml:"BatchSize"`
	// MaxBatchWaitTime is the maximum time to wait in milliseconds before sending a batch to the verifier.
	MaxBatchWaitTime int `toml:"MaxBatchWaitTime"`
	// MaxResponseBytes is the maximum response size in bytes the client will accept.
	// 0 uses DefaultMaxResponseBytes (4MB).
	MaxResponseBytes int `toml:"MaxResponseBytes"`
	AggregatorReaderConfig
	RestReaderConfig
}

// ReaderType is the type of reader to use (aggregator).
type ReaderType string

const (
	ReaderTypeAggregator ReaderType = "aggregator"
	ReaderTypeRest       ReaderType = "rest"
)

const (
	DefaultMaxResponseBytes = 4 << 20   // 4MB, matches gRPC default
	MaxAllowedResponseBytes = 100 << 20 // 100MB ceiling
)

// AggregatorReaderConfig allows you to change the aggregator reader used by the indexer.
type AggregatorReaderConfig struct {
	// Address is the known grpc address of the aggregator.
	Address string `toml:"Address"`
	// Since is the unix timestamp in seconds to start reading from.
	Since int64 `toml:"Since"`
	// APIKey is the client's API Key (UUID format)
	APIKey string `toml:"APIKey"`
	// Secret is the HMAC secret used to sign requests
	Secret string `toml:"Secret"`
	// InsecureConnection disables TLS for the aggregator gRPC connection.
	// Only use this for testing when custom certificates cannot be injected.
	InsecureConnection bool `toml:"InsecureConnection"`
}

// RestReaderConfig allows you to change the rest reader used by the indexer.
type RestReaderConfig struct {
	// BaseURL is the base URL for the rest reader.
	BaseURL string `toml:"BaseURL"`
	// RequestTimeout is the timeout in seconds for the rest reader.
	RequestTimeout int64 `toml:"RequestTimeout"`
}

// LoadConfig loads configuration from a TOML file.
// It also loads and merges generated config (if GeneratedConfigPath is set) and secrets from secrets.toml.
// It returns an error if the config file cannot be read or parsed.
// Secrets and generated config are optional - if the files don't exist, the config will load without them.
// The third return value contains qualifiers from the generated config that had no matching verifier
// in the main config.
func LoadConfig() (*Config, []string, error) {
	configPath, ok := os.LookupEnv("INDEXER_CONFIG_PATH")
	if !ok {
		configPath = "config.toml"
	}
	data, err := os.ReadFile(configPath) //nolint:gosec // file is either config.toml or set by user through env var
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read config file config.toml: %w", err)
	}

	config, err := LoadConfigFromBytes(data)
	if err != nil {
		return nil, nil, err
	}

	// Load and merge generated config
	generated, err := LoadGeneratedConfig(configPath, config)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to load generated config: %w", err)
	}

	unmatchedQualifiers := MergeGeneratedConfig(config, generated)

	// Load and merge secrets
	secrets, err := LoadSecrets()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to load secrets: %w", err)
	}

	if err := MergeSecrets(config, secrets); err != nil {
		return nil, nil, fmt.Errorf("failed to merge secrets: %w", err)
	}

	if err := config.Validate(); err != nil {
		return nil, nil, fmt.Errorf("config validation failed: %w", err)
	}

	return config, unmatchedQualifiers, nil
}

// LoadConfigFromBytes loads configuration from TOML bytes.
// It returns an error if the data cannot be parsed.
func LoadConfigFromBytes(data []byte) (*Config, error) {
	var config Config
	if err := toml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse TOML config: %w", err)
	}

	return &config, nil
}

// DiscoveryConfigs returns the list of discovery configs to use for message discovery.
func (c *Config) DiscoveryConfigs() []DiscoveryConfig {
	return c.Discoveries
}

// Validate performs basic validation on the configuration.
// It returns an error if the configuration is invalid.
func (c *Config) Validate() error {
	if err := c.Scheduler.Validate(); err != nil {
		return fmt.Errorf("scheduler config validation failed: %w", err)
	}

	if len(c.Discoveries) < 1 {
		return fmt.Errorf("at least one discovery config is required")
	}
	for i, d := range c.Discoveries {
		if err := d.Validate(i); err != nil {
			return fmt.Errorf("discovery config[%d] validation failed: %w", i, err)
		}
	}

	for i, v := range c.Verifiers {
		if err := v.Validate(i); err != nil {
			return fmt.Errorf("verifier[%d] validation failed: %w", i, err)
		}
	}

	// Validate storage config
	if err := c.Storage.Validate(); err != nil {
		return fmt.Errorf("storage config validation failed: %w", err)
	}

	if c.Monitoring.Enabled && c.Monitoring.Type == "" {
		return fmt.Errorf("monitoring type is required when monitoring is enabled")
	}

	// Validate beholder config if monitoring is enabled and type is beholder
	if c.Monitoring.Enabled && c.Monitoring.Type == "beholder" {
		if err := c.Monitoring.Beholder.Validate(); err != nil {
			return fmt.Errorf("beholder config validation failed: %w", err)
		}
	}

	return nil
}

func (s *SchedulerConfig) Validate() error {
	if s.BaseDelay <= 0 {
		return fmt.Errorf("base delay must be greater than 0")
	}

	if s.MaxDelay <= s.BaseDelay {
		return fmt.Errorf("max delay must be greater than base delay")
	}

	if s.TickerInterval <= 20 {
		return fmt.Errorf("ticker interval must be greater than 20 milliseconds")
	}

	if s.VerificationVisibilityWindow <= (s.MaxDelay / 1000) {
		return fmt.Errorf("verification visability window must be greater than max delay after seconds conversion")
	}

	return nil
}

// Validate performs validation on the storage configuration.
func (s *StorageConfig) Validate() error {
	if s.Strategy == "" {
		return fmt.Errorf("storage strategy is required")
	}

	if s.Strategy != StorageStrategySingle {
		return fmt.Errorf("unknown storage strategy: %s (must be 'single')", s.Strategy)
	}

	if s.Single == nil {
		return fmt.Errorf("single storage config is required when strategy is single")
	}

	return s.Single.Validate()
}

// Validate performs validation on the single storage configuration.
func (s *SingleStorageConfig) Validate() error {
	if s.Type == "" {
		return fmt.Errorf("storage backend type is required")
	}

	if s.Type != StorageBackendTypePostgres {
		return fmt.Errorf("unknown storage backend type: %s (must be 'postgres')", s.Type)
	}

	if s.Postgres == nil {
		return fmt.Errorf("postgres storage config is required when type is postgres")
	}

	return s.Postgres.Validate()
}

func (v *VerifierConfig) Validate(index int) error {
	switch v.Type {
	case ReaderTypeAggregator:
		if err := v.AggregatorReaderConfig.Validate(index); err != nil {
			return err
		}
	case ReaderTypeRest:
		if err := v.RestReaderConfig.Validate(index); err != nil {
			return err
		}
	default:
		return errors.New("invalid verifier type")
	}
	return validateMaxResponseBytes(v.MaxResponseBytes, fmt.Sprintf("verifier %d", index))
}

// Validate performs validation on the aggregator reader configuration.
func (a *AggregatorReaderConfig) Validate(index int) error {
	if a.Address == "" {
		return fmt.Errorf("reader %d aggregator address is required", index)
	}

	if a.Since < 0 {
		return fmt.Errorf("reader %d aggregator since must be non-negative, got %d", index, a.Since)
	}

	if a.APIKey != "" {
		if err := hmacutil.ValidateAPIKey(a.APIKey); err != nil {
			return fmt.Errorf("reader %d: %w", index, err)
		}
	}
	if a.Secret != "" {
		if err := hmacutil.ValidateSecret(a.Secret); err != nil {
			return fmt.Errorf("reader %d: %w", index, err)
		}
	}

	return nil
}

// Validate validates the discovery config (aggregator fields plus PollInterval/Timeout).
func (d *DiscoveryConfig) Validate(index int) error {
	if err := d.AggregatorReaderConfig.Validate(index); err != nil {
		return err
	}
	if d.PollInterval <= 0 {
		return fmt.Errorf("discovery[%d]: poll interval must be greater than 0", index)
	}
	if d.Timeout <= 0 || d.Timeout <= d.PollInterval {
		return fmt.Errorf("discovery[%d]: timeout must be greater than poll interval", index)
	}
	return validateMaxResponseBytes(d.MaxResponseBytes, fmt.Sprintf("discovery[%d]", index))
}

func (r *RestReaderConfig) Validate(index int) error {
	if r.BaseURL == "" {
		return fmt.Errorf("verifier %d base url is required", index)
	}

	if r.RequestTimeout < 0 {
		return fmt.Errorf("verifier %d request timeout must be non-negative, got %d", index, r.RequestTimeout)
	}

	return nil
}

func validateMaxResponseBytes(v int, prefix string) error {
	if v < 0 {
		return fmt.Errorf("%s max response bytes must be non-negative, got %d", prefix, v)
	}
	if v > MaxAllowedResponseBytes {
		return fmt.Errorf("%s max response bytes must be <= %d, got %d", prefix, MaxAllowedResponseBytes, v)
	}
	return nil
}

// EffectiveMaxResponseBytes returns v if positive, otherwise DefaultMaxResponseBytes.
func EffectiveMaxResponseBytes(v int) int {
	if v > 0 {
		return v
	}
	return DefaultMaxResponseBytes
}

// Validate performs validation on the postgres configuration.
func (p *PostgresConfig) Validate() error {
	if p.URI == "" {
		return fmt.Errorf("postgres URI is required")
	}

	if p.MaxOpenConnections <= 0 {
		return fmt.Errorf("postgres max_open_connections must be positive, got %d", p.MaxOpenConnections)
	}

	if p.MaxIdleConnections < 0 {
		return fmt.Errorf("postgres max_idle_connections must be non-negative, got %d", p.MaxIdleConnections)
	}

	if p.MaxIdleConnections > p.MaxOpenConnections {
		return fmt.Errorf("postgres max_idle_connections (%d) cannot be greater than max_open_connections (%d)", p.MaxIdleConnections, p.MaxOpenConnections)
	}

	if p.IdleInTxSessionTimeout < 0 {
		return fmt.Errorf("postgres idle_in_tx_session_timeout must be non-negative, got %d", p.IdleInTxSessionTimeout)
	}

	if p.LockTimeout < 0 {
		return fmt.Errorf("postgres lock_timeout must be non-negative, got %d", p.LockTimeout)
	}

	return nil
}
